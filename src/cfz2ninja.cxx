/** zsconfuz-alt cfz2ninja.cxx
    (C) 2019 Erik Zscheile
    License: ISC

 USAGE: zscfz2ninja < ZSconfuz.txt > .zscfzFiles/build.ninja
 a program which converts a subset of zsconfuz into a ninja file
 expects that ninja is called with '-C .zscfzFiles'

 **/

// ZS
#include <zs/confuz-common/cmdqueue.hpp>
#include <zs/confuz-common/dflout.h>

// STDC
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// STL
#include <exception>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <vector>

using namespace std;

static auto get_cq_wrapper(istream &in) {
  try {
    return zs::confuz::cmdqueue_t::read_from_stream(in, ".zscfzFiles/zscfz.txt");
  } catch(const zs::confuz::cmdqueue_parse_error &e) {
    cerr << "zscfz2ninja: ERROR: " << e.what() << '\n';
    exit(1);
  }
}

// prevent quoting if unnecessary
#define quoted_wrapper zs::confuz::cmdqueue_t::arg2quoted

static string get_steplist(size_t cnt_befsec, size_t cnt_aftsec) {
  // if there are commands in the section, we don't need to reference the section itself
  if(cnt_befsec != (cnt_aftsec - 1))
    ++cnt_befsec;

  string ret;
  ret.reserve((cnt_aftsec - cnt_befsec) * 12);

  for(size_t i = cnt_befsec; i < cnt_aftsec; ++i)
    (ret += " L") += to_string(i);

  return ret;
}

// NOTE: this automatically appends a newline to the path
static void print_resolved_path(const char *rsvtool, const string &x) {
  ostringstream ss;
  ss << rsvtool << ' ' << quoted(x);
  const auto real_cmdl = ss.str();
  cout << flush;
  if(const int rc = system(real_cmdl.c_str())) {
    cerr << "zscfz2ninja: ERROR: call to '" << real_cmdl << "' failed with $? = " << rc << '\n';
    exit(1);
  }
}

int main(int argc, char *argv[]) {
  auto cq = get_cq_wrapper(cin);
  cq.remove_empty_sections();

  cout <<
    "# This file is generated by zscfz2ninja\n"
    "\n"
    "base_dir = ";
  print_resolved_path("realpath", ".");
  cout <<
    "results_file = ";
  print_resolved_path("realpath", cq.output);
  cout <<
    "dynqueue_file = zscfz2.txt\n"
    "\n"
    "rule regenerate\n"
    "  command = zscfz2ninja < $in > $out\n"
    "  description = regenerate $out from $in\n"
    "  generator = 1\n"
    "\n"
    "rule mkempty\n"
    "  command = rm -f $out && touch $out\n"
    "  description = > $out\n"
    "\n"
    "rule runcmd\n"
    "  command = ( cd \"$base_dir\" && zscfz-runcmd $COMMAND ) 5>>$results_file 6>>$dynqueue_file && touch $out\n"
    "  description = $COMMAND\n"
    "\n"
    "rule section\n"
    "  command = zscfz-ppsec $NAME && touch $out\n"
    "  description = : $NAME\n"
    "  pool = console\n"
    "\n"
    "build build.ninja: regenerate zscfz.txt\n"
    "build L0 $results_file: mkempty\n"
    "\n";

  size_t cnt_befsec = 0, cnt_aftsec = 1;

  for(const auto &sec : cq.cmds) {
    cout
      << "build L" << cnt_aftsec << ": section" << get_steplist(cnt_befsec, cnt_aftsec)
      << "\n  NAME = " << quoted_wrapper(sec.first) << '\n';
    cnt_befsec = cnt_aftsec++;

    for(const auto &cmdx : sec.second) {
      cout << "build L" << cnt_aftsec << ": runcmd L" << cnt_befsec << ' ';
      // we exploit the fact that the arguments in {cmdx} are separated using null bytes.
      print_resolved_path("which", string(cmdx.c_str()));
      cout << "  COMMAND =";
      ++cnt_aftsec;
      for(const auto &arg : cq.cmd2argv(cmdx))
        cout << ' ' << quoted_wrapper(arg);
      cout << '\n';
    }
    cout << '\n';
  }

  cout
    << "build all: phony build.ninja" << get_steplist(cnt_befsec, cnt_aftsec) << "\n"
       "default all\n";

  return 0;
}
